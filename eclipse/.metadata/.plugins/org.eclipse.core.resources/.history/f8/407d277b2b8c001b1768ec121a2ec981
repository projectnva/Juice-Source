package com.github.lunatrius.schematica.network.message;

import com.github.lunatrius.core.util.MBlockPos;
import com.github.lunatrius.schematica.api.ISchematic;
import com.github.lunatrius.schematica.handler.DownloadHandler;
import com.github.lunatrius.schematica.nbt.NBTHelper;
import io.netty.buffer.ByteBuf;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.tileentity.TileEntity;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.common.network.simpleimpl.IMessageHandler;
import net.minecraftforge.fml.common.network.simpleimpl.MessageContext;
import net.minecraftforge.fml.common.registry.FMLControlledNamespacedRegistry;
import net.minecraftforge.fml.common.registry.GameData;

public class MessageDownloadChunk implements IMessage, IMessageHandler {

    public static final FMLControlledNamespacedRegistry BLOCK_REGISTRY = GameData.getBlockRegistry();
    public int baseX;
    public int baseY;
    public int baseZ;
    public short[][][] blocks;
    public byte[][][] metadata;
    public List tileEntities;
    public List entities;

    public MessageDownloadChunk() {}

    public MessageDownloadChunk(ISchematic schematic, int baseX, int baseY, int baseZ) {
        this.baseX = baseX;
        this.baseY = baseY;
        this.baseZ = baseZ;
        this.blocks = new short[16][16][16];
        this.metadata = new byte[16][16][16];
        this.tileEntities = new ArrayList();
        this.entities = new ArrayList();
        MBlockPos pos = new MBlockPos();

        for (int x = 0; x < 16; ++x) {
            for (int y = 0; y < 16; ++y) {
                for (int z = 0; z < 16; ++z) {
                    pos.set(baseX + x, baseY + y, baseZ + z);
                    IBlockState blockState = schematic.getBlockState(pos);
                    Block block = blockState.getBlock();
                    int id = MessageDownloadChunk.BLOCK_REGISTRY.getId(block);

                    this.blocks[x][y][z] = (short) id;
                    this.metadata[x][y][z] = (byte) block.getMetaFromState(blockState);
                    TileEntity tileEntity = schematic.getTileEntity(pos);

                    if (tileEntity != null) {
                        this.tileEntities.add(tileEntity);
                    }
                }
            }
        }

    }

    private void copyToSchematic(ISchematic schematic) {
        MBlockPos pos = new MBlockPos();

        for (int x = 0; x < 16; ++x) {
            for (int tileEntity = 0; tileEntity < 16; ++tileEntity) {
                for (int z = 0; z < 16; ++z) {
                    short id = this.blocks[x][tileEntity][z];
                    byte meta = this.metadata[x][tileEntity][z];
                    Block block = (Block) MessageDownloadChunk.BLOCK_REGISTRY.getObjectById(id);

                    pos.set(this.baseX + x, this.baseY + tileEntity, this.baseZ + z);
                    schematic.setBlockState(pos, block.getStateFromMeta(meta));
                }
            }
        }

        Iterator iterator = this.tileEntities.iterator();

        while (iterator.hasNext()) {
            TileEntity tileentity = (TileEntity) iterator.next();

            schematic.setTileEntity(tileentity.getPos(), tileentity);
        }

    }

    public void fromBytes(ByteBuf buf) {
        this.baseX = buf.readShort();
        this.baseY = buf.readShort();
        this.baseZ = buf.readShort();
        this.blocks = new short[16][16][16];
        this.metadata = new byte[16][16][16];
        this.tileEntities = new ArrayList();
        this.entities = new ArrayList();

        for (int compound = 0; compound < 16; ++compound) {
            for (int compound2 = 0; compound2 < 16; ++compound2) {
                for (int z = 0; z < 16; ++z) {
                    this.blocks[compound][compound2][z] = buf.readShort();
                    this.metadata[compound][compound2][z] = buf.readByte();
                }
            }
        }

        NBTTagCompound nbttagcompound = ByteBufUtils.readTag(buf);

        this.tileEntities = NBTHelper.readTileEntitiesFromCompound(nbttagcompound, this.tileEntities);
        NBTTagCompound nbttagcompound1 = ByteBufUtils.readTag(buf);

        this.entities = NBTHelper.readEntitiesFromCompound(nbttagcompound1, this.entities);
    }

    public void toBytes(ByteBuf buf) {
        buf.writeShort(this.baseX);
        buf.writeShort(this.baseY);
        buf.writeShort(this.baseZ);

        for (int compound = 0; compound < 16; ++compound) {
            for (int compound1 = 0; compound1 < 16; ++compound1) {
                for (int z = 0; z < 16; ++z) {
                    buf.writeShort(this.blocks[compound][compound1][z]);
                    buf.writeByte(this.metadata[compound][compound1][z]);
                }
            }
        }

        NBTTagCompound nbttagcompound = NBTHelper.writeTileEntitiesToCompound(this.tileEntities);

        ByteBufUtils.writeTag(buf, nbttagcompound);
        NBTTagCompound nbttagcompound1 = NBTHelper.writeEntitiesToCompound(this.entities);

        ByteBufUtils.writeTag(buf, nbttagcompound1);
    }

    public IMessage onMessage(MessageDownloadChunk message, MessageContext ctx) {
        message.copyToSchematic(DownloadHandler.INSTANCE.schematic);
        return new MessageDownloadChunkAck(message.baseX, message.baseY, message.baseZ);
    }
}
