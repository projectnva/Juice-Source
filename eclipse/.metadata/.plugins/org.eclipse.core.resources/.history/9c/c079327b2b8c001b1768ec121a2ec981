package com.github.lunatrius.schematica.client.world;

import com.github.lunatrius.core.util.BlockPosHelper;
import com.github.lunatrius.core.util.MBlockPos;
import com.github.lunatrius.schematica.api.ISchematic;
import com.github.lunatrius.schematica.block.state.pattern.BlockStateReplacer;
import com.github.lunatrius.schematica.client.world.chunk.ChunkProviderSchematic;
import com.github.lunatrius.schematica.reference.Reference;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import net.minecraft.block.state.IBlockState;
import net.minecraft.block.state.pattern.BlockStateHelper;
import net.minecraft.client.Minecraft;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.client.network.NetHandlerPlayClient;
import net.minecraft.entity.Entity;
import net.minecraft.init.Blocks;
import net.minecraft.item.ItemStack;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumFacing;
import net.minecraft.world.EnumDifficulty;
import net.minecraft.world.EnumSkyBlock;
import net.minecraft.world.WorldSettings;
import net.minecraft.world.WorldType;
import net.minecraft.world.WorldSettings.GameType;
import net.minecraft.world.biome.BiomeGenBase;
import net.minecraft.world.chunk.IChunkProvider;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class SchematicWorld extends WorldClient {

    private static final WorldSettings WORLD_SETTINGS = new WorldSettings(0L, GameType.CREATIVE, false, false, WorldType.FLAT);
    private ISchematic schematic;
    public final MBlockPos position = new MBlockPos();
    public boolean isRendering;
    public boolean isRenderingLayer;
    public int renderingLayer;

    public SchematicWorld(ISchematic schematic) {
        super((NetHandlerPlayClient) null, SchematicWorld.WORLD_SETTINGS, 0, EnumDifficulty.PEACEFUL, Minecraft.getMinecraft().mcProfiler);
        this.schematic = schematic;
        Iterator iterator = schematic.getTileEntities().iterator();

        while (iterator.hasNext()) {
            TileEntity tileEntity = (TileEntity) iterator.next();

            this.initializeTileEntity(tileEntity);
        }

        this.isRendering = false;
        this.isRenderingLayer = false;
        this.renderingLayer = 0;
    }

    public IBlockState getBlockState(BlockPos pos) {
        return this.isRenderingLayer && this.renderingLayer != pos.getY() ? Blocks.air.getDefaultState() : this.schematic.getBlockState(pos);
    }

    public boolean setBlockState(BlockPos pos, IBlockState state, int flags) {
        return this.schematic.setBlockState(pos, state);
    }

    public TileEntity getTileEntity(BlockPos pos) {
        return this.isRenderingLayer && this.renderingLayer != pos.getY() ? null : this.schematic.getTileEntity(pos);
    }

    public void setTileEntity(BlockPos pos, TileEntity tileEntity) {
        this.schematic.setTileEntity(pos, tileEntity);
        this.initializeTileEntity(tileEntity);
    }

    public void removeTileEntity(BlockPos pos) {
        this.schematic.removeTileEntity(pos);
    }

    @SideOnly(Side.CLIENT)
    public int getLightFromNeighborsFor(EnumSkyBlock type, BlockPos pos) {
        return 15;
    }

    public float getLightBrightness(BlockPos pos) {
        return 1.0F;
    }

    public boolean isBlockNormalCube(BlockPos pos, boolean _default) {
        return this.getBlockState(pos).getBlock().isNormalCube(this, pos);
    }

    public void calculateInitialSkylight() {}

    protected void calculateInitialWeather() {}

    public void setSpawnPoint(BlockPos pos) {}

    protected int getRenderDistanceChunks() {
        return 0;
    }

    public boolean isAirBlock(BlockPos pos) {
        return this.getBlockState(pos).getBlock().isAir(this, pos);
    }

    public BiomeGenBase getBiomeGenForCoords(BlockPos pos) {
        return BiomeGenBase.jungle;
    }

    public int getWidth() {
        return this.schematic.getWidth();
    }

    public int getLength() {
        return this.schematic.getLength();
    }

    public int getHeight() {
        return this.schematic.getHeight();
    }

    @SideOnly(Side.CLIENT)
    public boolean extendedLevelsInChunkCache() {
        return false;
    }

    protected IChunkProvider createChunkProvider() {
        return new ChunkProviderSchematic(this);
    }

    public Entity getEntityByID(int id) {
        return null;
    }

    public boolean isSideSolid(BlockPos pos, EnumFacing side) {
        return this.isSideSolid(pos, side, false);
    }

    public boolean isSideSolid(BlockPos pos, EnumFacing side, boolean _default) {
        return this.getBlockState(pos).getBlock().isSideSolid(this, pos, side);
    }

    public void setSchematic(ISchematic schematic) {
        this.schematic = schematic;
    }

    public ISchematic getSchematic() {
        return this.schematic;
    }

    public void initializeTileEntity(TileEntity tileEntity) {
        tileEntity.setWorldObj(this);
        tileEntity.getBlockType();

        try {
            tileEntity.invalidate();
            tileEntity.validate();
        } catch (Exception exception) {
            Reference.logger.error("TileEntity validation for {} failed!", new Object[] { tileEntity.getClass(), exception});
        }

    }

    public void setIcon(ItemStack icon) {
        this.schematic.setIcon(icon);
    }

    public ItemStack getIcon() {
        return this.schematic.getIcon();
    }

    public List getTileEntities() {
        return this.schematic.getTileEntities();
    }

    public boolean toggleRendering() {
        this.isRendering = !this.isRendering;
        return this.isRendering;
    }

    public String getDebugDimensions() {
        return "WHL: " + this.getWidth() + " / " + this.getHeight() + " / " + this.getLength();
    }

    public int replaceBlock(BlockStateHelper matcher, BlockStateReplacer replacer, Map properties) {
        int count = 0;
        Iterator iterator = BlockPosHelper.getAllInBox(0, 0, 0, this.getWidth(), this.getHeight(), this.getLength()).iterator();

        while (iterator.hasNext()) {
            MBlockPos pos = (MBlockPos) iterator.next();
            IBlockState blockState = this.schematic.getBlockState(pos);

            if (!blockState.getBlock().hasTileEntity(blockState) && matcher.apply(blockState)) {
                IBlockState replacement = replacer.getReplacement(blockState, properties);

                if (!replacement.getBlock().hasTileEntity(replacement) && this.schematic.setBlockState(pos, replacement)) {
                    this.markBlockForUpdate(pos.add(this.position));
                    ++count;
                }
            }
        }

        return count;
    }

    public boolean isInside(BlockPos pos) {
        int x = pos.getX();
        int y = pos.getY();
        int z = pos.getZ();

        return x >= 0 && y >= 0 && z >= 0 && x < this.getWidth() && y < this.getHeight() && z < this.getLength();
    }
}
