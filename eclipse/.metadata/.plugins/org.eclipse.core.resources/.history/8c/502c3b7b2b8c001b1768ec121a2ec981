package com.github.lunatrius.schematica.client.renderer;

import com.github.lunatrius.core.client.renderer.GeometryTessellator;
import com.github.lunatrius.core.util.MBlockPos;
import com.github.lunatrius.core.util.vector.Vector3d;
import com.github.lunatrius.schematica.client.renderer.chunk.OverlayRenderDispatcher;
import com.github.lunatrius.schematica.client.renderer.chunk.container.SchematicChunkRenderContainer;
import com.github.lunatrius.schematica.client.renderer.chunk.container.SchematicChunkRenderContainerList;
import com.github.lunatrius.schematica.client.renderer.chunk.container.SchematicChunkRenderContainerVbo;
import com.github.lunatrius.schematica.client.renderer.chunk.overlay.ISchematicRenderChunkFactory;
import com.github.lunatrius.schematica.client.renderer.chunk.overlay.RenderOverlay;
import com.github.lunatrius.schematica.client.renderer.chunk.overlay.RenderOverlayList;
import com.github.lunatrius.schematica.client.renderer.chunk.proxy.SchematicRenderChunkList;
import com.github.lunatrius.schematica.client.renderer.chunk.proxy.SchematicRenderChunkVbo;
import com.github.lunatrius.schematica.client.renderer.shader.ShaderProgram;
import com.github.lunatrius.schematica.client.world.SchematicWorld;
import com.github.lunatrius.schematica.handler.ConfigurationHandler;
import com.github.lunatrius.schematica.proxy.ClientProxy;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.orbitclient.imsoogood.ez.orbitclient.modules.MissingBlockESP;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.RenderGlobal;
import net.minecraft.client.renderer.RenderHelper;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.WorldRenderer;
import net.minecraft.client.renderer.chunk.ChunkRenderDispatcher;
import net.minecraft.client.renderer.chunk.CompiledChunk;
import net.minecraft.client.renderer.chunk.RenderChunk;
import net.minecraft.client.renderer.chunk.VisGraph;
import net.minecraft.client.renderer.culling.Frustum;
import net.minecraft.client.renderer.culling.ICamera;
import net.minecraft.client.renderer.entity.RenderManager;
import net.minecraft.client.renderer.texture.TextureMap;
import net.minecraft.client.renderer.tileentity.TileEntityRendererDispatcher;
import net.minecraft.client.resources.IResourceManager;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.profiler.Profiler;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumWorldBlockLayer;
import net.minecraft.util.MathHelper;
import net.minecraft.util.MovingObjectPosition;
import net.minecraft.util.BlockPos.MutableBlockPos;
import net.minecraft.world.World;
import net.minecraftforge.client.event.RenderWorldLastEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL20;
import org.lwjgl.util.vector.Vector3f;

@SideOnly(Side.CLIENT)
public class RenderSchematic extends RenderGlobal {

    public static final RenderSchematic INSTANCE = new RenderSchematic(Minecraft.getMinecraft());
    public static final int RENDER_DISTANCE = 32;
    public static final int CHUNKS_XZ = 66;
    public static final int CHUNKS_Y = 16;
    public static final int CHUNKS = 69696;
    public static final int PASS = 2;
    private static final ShaderProgram SHADER_ALPHA = new ShaderProgram("schematica", (String) null, "shaders/alpha.frag");
    private static final Vector3d PLAYER_POSITION_OFFSET = new Vector3d();
    private final Minecraft mc;
    private final Profiler profiler;
    private final RenderManager renderManager;
    private final MBlockPos tmp = new MBlockPos();
    private SchematicWorld world;
    private Set chunksToUpdate = Sets.newLinkedHashSet();
    private final Set overlaysToUpdate = Sets.newLinkedHashSet();
    private List renderInfos = Lists.newArrayListWithCapacity(69696);
    private ViewFrustumOverlay viewFrustum;
    private double frustumUpdatePosX = Double.MIN_VALUE;
    private double frustumUpdatePosY = Double.MIN_VALUE;
    private double frustumUpdatePosZ = Double.MIN_VALUE;
    private int frustumUpdatePosChunkX = Integer.MIN_VALUE;
    private int frustumUpdatePosChunkY = Integer.MIN_VALUE;
    private int frustumUpdatePosChunkZ = Integer.MIN_VALUE;
    private double lastViewEntityX = Double.MIN_VALUE;
    private double lastViewEntityY = Double.MIN_VALUE;
    private double lastViewEntityZ = Double.MIN_VALUE;
    private double lastViewEntityPitch = Double.MIN_VALUE;
    private double lastViewEntityYaw = Double.MIN_VALUE;
    private final ChunkRenderDispatcher renderDispatcher = new ChunkRenderDispatcher();
    private final OverlayRenderDispatcher renderDispatcherOverlay = new OverlayRenderDispatcher();
    private SchematicChunkRenderContainer renderContainer;
    private int renderDistanceChunks = -1;
    private int countEntitiesTotal;
    private int countEntitiesRendered;
    private int countTileEntitiesTotal;
    private int countTileEntitiesRendered;
    private boolean vboEnabled = false;
    private ISchematicRenderChunkFactory renderChunkFactory;
    private double prevRenderSortX;
    private double prevRenderSortY;
    private double prevRenderSortZ;
    private boolean displayListEntitiesDirty = true;
    private int frameCount = 0;

    public RenderSchematic(Minecraft minecraft) {
        super(minecraft);
        this.mc = minecraft;
        this.profiler = minecraft.mcProfiler;
        this.renderManager = minecraft.getRenderManager();
        GL11.glTexParameteri(3553, 10242, 10497);
        GL11.glTexParameteri(3553, 10243, 10497);
        GlStateManager.bindTexture(0);
        this.vboEnabled = OpenGlHelper.useVbo();
        if (this.vboEnabled) {
            this.initVbo();
        } else {
            this.initList();
        }

    }

    private void initVbo() {
        this.renderContainer = new SchematicChunkRenderContainerVbo();
        this.renderChunkFactory = new ISchematicRenderChunkFactory() {
            public RenderChunk makeRenderChunk(World world, RenderGlobal renderGlobal, BlockPos pos, int index) {
                return new SchematicRenderChunkVbo(world, renderGlobal, pos, index);
            }

            public RenderOverlay makeRenderOverlay(World world, RenderGlobal renderGlobal, BlockPos pos, int index) {
                return new RenderOverlay(world, renderGlobal, pos, index);
            }
        };
    }

    private void initList() {
        this.renderContainer = new SchematicChunkRenderContainerList();
        this.renderChunkFactory = new ISchematicRenderChunkFactory() {
            public RenderChunk makeRenderChunk(World world, RenderGlobal renderGlobal, BlockPos pos, int index) {
                return new SchematicRenderChunkList(world, renderGlobal, pos, index);
            }

            public RenderOverlay makeRenderOverlay(World world, RenderGlobal renderGlobal, BlockPos pos, int index) {
                return new RenderOverlayList(world, renderGlobal, pos, index);
            }
        };
    }

    public void onResourceManagerReload(IResourceManager resourceManager) {}

    public void makeEntityOutlineShader() {}

    public void renderEntityOutlineFramebuffer() {}

    protected boolean isRenderEntityOutlines() {
        return false;
    }

    public void setWorldAndLoadRenderers(WorldClient worldClient) {
        if (worldClient instanceof SchematicWorld) {
            this.setWorldAndLoadRenderers((SchematicWorld) worldClient);
        } else {
            this.setWorldAndLoadRenderers((SchematicWorld) null);
        }

    }

    public void setWorldAndLoadRenderers(SchematicWorld world) {
        if (this.world != null) {
            this.world.removeWorldAccess(this);
        }

        this.frustumUpdatePosX = Double.MIN_VALUE;
        this.frustumUpdatePosY = Double.MIN_VALUE;
        this.frustumUpdatePosZ = Double.MIN_VALUE;
        this.frustumUpdatePosChunkX = Integer.MIN_VALUE;
        this.frustumUpdatePosChunkY = Integer.MIN_VALUE;
        this.frustumUpdatePosChunkZ = Integer.MIN_VALUE;
        this.renderManager.set(world);
        this.world = world;
        if (world != null) {
            world.addWorldAccess(this);
            this.loadRenderers();
        }

    }

    @SubscribeEvent
    public void onRenderWorldLast(RenderWorldLastEvent event) {
        EntityPlayerSP player = this.mc.thePlayer;

        if (player != null) {
            this.profiler.startSection("schematica");
            ClientProxy.setPlayerData(player, event.partialTicks);
            SchematicWorld schematic = ClientProxy.schematic;
            boolean isRenderingSchematic = schematic != null && schematic.isRendering;

            this.profiler.startSection("schematic");
            if (isRenderingSchematic) {
                GlStateManager.pushMatrix();
                this.renderSchematic(schematic, event.partialTicks);
                GlStateManager.popMatrix();
            }

            this.profiler.endStartSection("guide");
            if (ClientProxy.isRenderingGuide || isRenderingSchematic) {
                GlStateManager.pushMatrix();
                this.renderOverlay(schematic, isRenderingSchematic);
                GlStateManager.popMatrix();
            }

            this.profiler.endSection();
            this.profiler.endSection();
        }

    }

    private void renderSchematic(SchematicWorld schematic, float partialTicks) {
        if (this.world != schematic) {
            this.world = schematic;
            this.loadRenderers();
        }

        RenderSchematic.PLAYER_POSITION_OFFSET.set(ClientProxy.playerPosition).sub((double) this.world.position.x, (double) this.world.position.y, (double) this.world.position.z);
        if (OpenGlHelper.shadersSupported && ConfigurationHandler.enableAlpha) {
            GL20.glUseProgram(RenderSchematic.SHADER_ALPHA.getProgram());
            GL20.glUniform1f(GL20.glGetUniformLocation(RenderSchematic.SHADER_ALPHA.getProgram(), "alpha_multiplier"), ConfigurationHandler.alpha);
        }

        int fps = Math.max(Minecraft.getDebugFPS(), 30);

        this.renderWorld(partialTicks, System.nanoTime() + (long) (1000000000 / fps));
        if (OpenGlHelper.shadersSupported && ConfigurationHandler.enableAlpha) {
            GL20.glUseProgram(0);
        }

    }

    private void renderOverlay(SchematicWorld schematic, boolean isRenderingSchematic) {
        GlStateManager.disableTexture2D();
        GlStateManager.enableBlend();
        GlStateManager.tryBlendFuncSeparate(770, 771, 1, 0);
        GL11.glEnable(2848);
        GeometryTessellator tessellator = GeometryTessellator.getInstance();

        tessellator.setTranslation(-ClientProxy.playerPosition.x, -ClientProxy.playerPosition.y, -ClientProxy.playerPosition.z);
        tessellator.setDelta(ConfigurationHandler.blockDelta);
        if (ClientProxy.isRenderingGuide) {
            tessellator.beginQuads();
            tessellator.drawCuboid(ClientProxy.pointA, 63, 1069481984);
            tessellator.drawCuboid(ClientProxy.pointB, 63, 1056964799);
            tessellator.draw();
        }

        tessellator.beginLines();
        if (ClientProxy.isRenderingGuide) {
            tessellator.drawCuboid(ClientProxy.pointA, 63, 1069481984);
            tessellator.drawCuboid(ClientProxy.pointB, 63, 1056964799);
            tessellator.drawCuboid((BlockPos) ClientProxy.pointMin, ClientProxy.pointMax, 63, 2130755328);
        }

        if (isRenderingSchematic) {
            this.tmp.set(schematic.position.x + schematic.getWidth() - 1, schematic.position.y + schematic.getHeight() - 1, schematic.position.z + schematic.getLength() - 1);
            tessellator.drawCuboid((BlockPos) schematic.position, this.tmp, 63, 2143223999);
        }

        tessellator.draw();
        GlStateManager.depthMask(false);
        this.renderContainer.renderOverlay();
        GlStateManager.depthMask(true);
        GL11.glDisable(2848);
        GlStateManager.disableBlend();
        GlStateManager.enableTexture2D();
    }

    private void renderWorld(float partialTicks, long finishTimeNano) {
        GlStateManager.enableCull();
        this.profiler.endStartSection("culling");
        Frustum frustum = new Frustum();
        Entity entity = this.mc.getRenderViewEntity();
        double x = RenderSchematic.PLAYER_POSITION_OFFSET.x;
        double y = RenderSchematic.PLAYER_POSITION_OFFSET.y;
        double z = RenderSchematic.PLAYER_POSITION_OFFSET.z;

        frustum.setPosition(x, y, z);
        GlStateManager.shadeModel(7425);
        this.profiler.endStartSection("prepareterrain");
        this.mc.getTextureManager().bindTexture(TextureMap.locationBlocksTexture);
        RenderHelper.disableStandardItemLighting();
        this.profiler.endStartSection("terrain_setup");
        this.setupTerrain(entity, (double) partialTicks, frustum, this.frameCount++, this.isInsideWorld(x, y, z));
        this.profiler.endStartSection("updatechunks");
        this.updateChunks(finishTimeNano / 2L);
        this.profiler.endStartSection("terrain");
        GlStateManager.matrixMode(5888);
        GlStateManager.pushMatrix();
        GlStateManager.enableBlend();
        GlStateManager.tryBlendFuncSeparate(770, 771, 1, 0);
        this.renderBlockLayer(EnumWorldBlockLayer.SOLID, (double) partialTicks, 2, entity);
        this.renderBlockLayer(EnumWorldBlockLayer.CUTOUT_MIPPED, (double) partialTicks, 2, entity);
        this.mc.getTextureManager().getTexture(TextureMap.locationBlocksTexture).setBlurMipmap(false, false);
        this.renderBlockLayer(EnumWorldBlockLayer.CUTOUT, (double) partialTicks, 2, entity);
        this.mc.getTextureManager().getTexture(TextureMap.locationBlocksTexture).restoreLastBlurMipmap();
        GlStateManager.disableBlend();
        GlStateManager.shadeModel(7424);
        GlStateManager.alphaFunc(516, 0.1F);
        GlStateManager.matrixMode(5888);
        GlStateManager.popMatrix();
        GlStateManager.pushMatrix();
        this.profiler.endStartSection("entities");
        RenderHelper.enableStandardItemLighting();
        GlStateManager.enableBlend();
        GlStateManager.tryBlendFuncSeparate(770, 771, 1, 0);
        this.renderEntities(entity, frustum, partialTicks);
        GlStateManager.disableBlend();
        RenderHelper.disableStandardItemLighting();
        this.disableLightmap();
        GlStateManager.matrixMode(5888);
        GlStateManager.popMatrix();
        GlStateManager.enableCull();
        GlStateManager.alphaFunc(516, 0.1F);
        this.mc.getTextureManager().bindTexture(TextureMap.locationBlocksTexture);
        GlStateManager.shadeModel(7425);
        GlStateManager.depthMask(false);
        GlStateManager.pushMatrix();
        this.profiler.endStartSection("translucent");
        GlStateManager.enableBlend();
        GlStateManager.tryBlendFuncSeparate(770, 771, 1, 0);
        this.renderBlockLayer(EnumWorldBlockLayer.TRANSLUCENT, (double) partialTicks, 2, entity);
        GlStateManager.disableBlend();
        GlStateManager.popMatrix();
        GlStateManager.depthMask(true);
        GlStateManager.shadeModel(7424);
        GlStateManager.enableCull();
    }

    private boolean isInsideWorld(double x, double y, double z) {
        return x >= -1.0D && y >= -1.0D && z >= -1.0D && x <= (double) this.world.getWidth() && y <= (double) this.world.getHeight() && z <= (double) this.world.getLength();
    }

    private void disableLightmap() {
        GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
        GlStateManager.disableTexture2D();
        GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
    }

    public void refresh() {
        MissingBlockESP.clearBlockPos();
        this.loadRenderers();
    }

    public void loadRenderers() {
        if (this.world != null) {
            this.displayListEntitiesDirty = true;
            this.renderDistanceChunks = ConfigurationHandler.renderDistance;
            boolean vbo = this.vboEnabled;

            this.vboEnabled = OpenGlHelper.useVbo();
            if (vbo && !this.vboEnabled) {
                this.initList();
            } else if (!vbo && this.vboEnabled) {
                this.initVbo();
            }

            if (this.viewFrustum != null) {
                this.viewFrustum.deleteGlResources();
            }

            this.stopChunkUpdates();
            this.viewFrustum = new ViewFrustumOverlay(this.world, this.renderDistanceChunks, this, this.renderChunkFactory);
            double posX = RenderSchematic.PLAYER_POSITION_OFFSET.x;
            double posZ = RenderSchematic.PLAYER_POSITION_OFFSET.z;

            this.viewFrustum.updateChunkPositions(posX, posZ);
        }

    }

    protected void stopChunkUpdates() {
        this.chunksToUpdate.clear();
        this.overlaysToUpdate.clear();
        this.renderDispatcher.stopChunkUpdates();
        this.renderDispatcherOverlay.stopChunkUpdates();
    }

    public void createBindEntityOutlineFbs(int width, int height) {}

    public void renderEntities(Entity renderViewEntity, ICamera camera, float partialTicks) {
        boolean entityPass = false;

        this.profiler.startSection("prepare");
        TileEntityRendererDispatcher.instance.cacheActiveRenderInfo(this.world, this.mc.getTextureManager(), this.mc.fontRendererObj, renderViewEntity, partialTicks);
        this.renderManager.cacheActiveRenderInfo(this.world, this.mc.fontRendererObj, renderViewEntity, this.mc.pointedEntity, this.mc.gameSettings, partialTicks);
        this.countEntitiesTotal = 0;
        this.countEntitiesRendered = 0;
        this.countTileEntitiesTotal = 0;
        this.countTileEntitiesRendered = 0;
        double x = RenderSchematic.PLAYER_POSITION_OFFSET.x;
        double y = RenderSchematic.PLAYER_POSITION_OFFSET.y;
        double z = RenderSchematic.PLAYER_POSITION_OFFSET.z;

        TileEntityRendererDispatcher.staticPlayerX = x;
        TileEntityRendererDispatcher.staticPlayerY = y;
        TileEntityRendererDispatcher.staticPlayerZ = z;
        TileEntityRendererDispatcher.instance.entityX = x;
        TileEntityRendererDispatcher.instance.entityY = y;
        TileEntityRendererDispatcher.instance.entityZ = z;
        this.renderManager.setRenderPosition(x, y, z);
        this.mc.entityRenderer.enableLightmap();
        this.profiler.endStartSection("blockentities");
        RenderHelper.enableStandardItemLighting();
        Iterator iterator = this.renderInfos.iterator();

        while (iterator.hasNext()) {
            RenderSchematic.ContainerLocalRenderInformation renderInfo = (RenderSchematic.ContainerLocalRenderInformation) iterator.next();
            Iterator iterator1 = renderInfo.renderChunk.getCompiledChunk().getTileEntities().iterator();

            while (iterator1.hasNext()) {
                TileEntity tileEntity = (TileEntity) iterator1.next();
                AxisAlignedBB renderBB = tileEntity.getRenderBoundingBox();

                ++this.countTileEntitiesTotal;
                if (tileEntity.shouldRenderInPass(0) && camera.isBoundingBoxInFrustum(renderBB) && this.mc.theWorld.isAirBlock(tileEntity.getPos().add(this.world.position))) {
                    TileEntityRendererDispatcher.instance.renderTileEntity(tileEntity, partialTicks, -1);
                    ++this.countTileEntitiesRendered;
                }
            }
        }

        this.mc.entityRenderer.disableLightmap();
        this.profiler.endSection();
    }

    public String getDebugInfoRenders() {
        int total = this.viewFrustum.renderChunks.length;
        int rendered = 0;
        Iterator iterator = this.renderInfos.iterator();

        while (iterator.hasNext()) {
            RenderSchematic.ContainerLocalRenderInformation renderInfo = (RenderSchematic.ContainerLocalRenderInformation) iterator.next();
            CompiledChunk compiledChunk = renderInfo.renderChunk.compiledChunk;

            if (compiledChunk != CompiledChunk.DUMMY && !compiledChunk.isEmpty()) {
                ++rendered;
            }
        }

        return String.format("C: %d/%d %sD: %d, %s", new Object[] { Integer.valueOf(rendered), Integer.valueOf(total), this.mc.renderChunksMany ? "(s) " : "", Integer.valueOf(this.renderDistanceChunks), this.renderDispatcher.getDebugInfo()});
    }

    public String getDebugInfoEntities() {
        return String.format("E: %d/%d", new Object[] { Integer.valueOf(this.countEntitiesRendered), Integer.valueOf(this.countEntitiesTotal)});
    }

    public String getDebugInfoTileEntities() {
        return String.format("TE: %d/%d", new Object[] { Integer.valueOf(this.countTileEntitiesRendered), Integer.valueOf(this.countTileEntitiesTotal)});
    }

    public void setupTerrain(Entity viewEntity, double partialTicks, ICamera camera, int frameCount, boolean playerSpectator) {
        if (ConfigurationHandler.renderDistance != this.renderDistanceChunks || this.vboEnabled != OpenGlHelper.useVbo()) {
            this.loadRenderers();
        }

        this.profiler.startSection("camera");
        double posX = RenderSchematic.PLAYER_POSITION_OFFSET.x;
        double posY = RenderSchematic.PLAYER_POSITION_OFFSET.y;
        double posZ = RenderSchematic.PLAYER_POSITION_OFFSET.z;
        double deltaX = posX - this.frustumUpdatePosX;
        double deltaY = posY - this.frustumUpdatePosY;
        double deltaZ = posZ - this.frustumUpdatePosZ;
        int chunkCoordX = MathHelper.floor_double(posX) >> 4;
        int chunkCoordY = MathHelper.floor_double(posY) >> 4;
        int chunkCoordZ = MathHelper.floor_double(posZ) >> 4;

        if (this.frustumUpdatePosChunkX != chunkCoordX || this.frustumUpdatePosChunkY != chunkCoordY || this.frustumUpdatePosChunkZ != chunkCoordZ || deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ > 16.0D) {
            this.frustumUpdatePosX = posX;
            this.frustumUpdatePosY = posY;
            this.frustumUpdatePosZ = posZ;
            this.frustumUpdatePosChunkX = chunkCoordX;
            this.frustumUpdatePosChunkY = chunkCoordY;
            this.frustumUpdatePosChunkZ = chunkCoordZ;
            this.viewFrustum.updateChunkPositions(posX, posZ);
        }

        this.profiler.endStartSection("renderlistcamera");
        this.renderContainer.initialize(posX, posY, posZ);
        this.profiler.endStartSection("culling");
        BlockPos posEye = new BlockPos(posX, posY + (double) viewEntity.getEyeHeight(), posZ);
        RenderChunk renderchunk = this.viewFrustum.getRenderChunk(posEye);
        RenderOverlay renderoverlay = this.viewFrustum.getRenderOverlay(posEye);

        this.displayListEntitiesDirty = this.displayListEntitiesDirty || !this.chunksToUpdate.isEmpty() || posX != this.lastViewEntityX || posY != this.lastViewEntityY || posZ != this.lastViewEntityZ || (double) viewEntity.rotationPitch != this.lastViewEntityPitch || (double) viewEntity.rotationYaw != this.lastViewEntityYaw;
        this.lastViewEntityX = posX;
        this.lastViewEntityY = posY;
        this.lastViewEntityZ = posZ;
        this.lastViewEntityPitch = (double) viewEntity.rotationPitch;
        this.lastViewEntityYaw = (double) viewEntity.rotationYaw;
        RenderSchematic.ContainerLocalRenderInformation renderschematic_containerlocalrenderinformation;

        if (this.displayListEntitiesDirty) {
            this.displayListEntitiesDirty = false;
            this.renderInfos = Lists.newArrayListWithCapacity(69696);
            LinkedList set = Lists.newLinkedList();
            boolean set1 = this.mc.renderChunksMany;
            BlockPos renderOverlay;

            if (renderchunk == null) {
                int renderInfo = posEye.getY() > 0 ? 248 : 8;

                for (int renderInfo1 = -this.renderDistanceChunks; renderInfo1 <= this.renderDistanceChunks; ++renderInfo1) {
                    for (int renderChunk = -this.renderDistanceChunks; renderChunk <= this.renderDistanceChunks; ++renderChunk) {
                        renderOverlay = new BlockPos((renderInfo1 << 4) + 8, renderInfo, (renderChunk << 4) + 8);
                        RenderChunk facing = this.viewFrustum.getRenderChunk(renderOverlay);
                        RenderOverlay renderOverlay1 = this.viewFrustum.getRenderOverlay(renderOverlay);

                        if (facing != null && camera.isBoundingBoxInFrustum(facing.boundingBox)) {
                            facing.setFrameIndex(frameCount);
                            renderOverlay1.setFrameIndex(frameCount);
                            set.add(new RenderSchematic.ContainerLocalRenderInformation(facing, renderOverlay1, (EnumFacing) null, 0));
                        }
                    }
                }
            } else {
                boolean flag = false;

                renderschematic_containerlocalrenderinformation = new RenderSchematic.ContainerLocalRenderInformation(renderchunk, renderoverlay, (EnumFacing) null, 0);
                Set set = this.getVisibleSides(posEye);

                if (set.size() == 1) {
                    Vector3f vector3f = this.getViewVector(viewEntity, partialTicks);
                    EnumFacing enumfacing = EnumFacing.getFacingFromVector(vector3f.x, vector3f.y, vector3f.z).getOpposite();

                    set.remove(enumfacing);
                }

                if (set.isEmpty()) {
                    flag = true;
                }

                if (flag && !playerSpectator) {
                    this.renderInfos.add(renderschematic_containerlocalrenderinformation);
                } else {
                    if (playerSpectator && this.world.getBlockState(posEye).getBlock().isOpaqueCube()) {
                        set1 = false;
                    }

                    renderchunk.setFrameIndex(frameCount);
                    renderoverlay.setFrameIndex(frameCount);
                    set.add(renderschematic_containerlocalrenderinformation);
                }
            }

            while (!set.isEmpty()) {
                RenderSchematic.ContainerLocalRenderInformation renderschematic_containerlocalrenderinformation1 = (RenderSchematic.ContainerLocalRenderInformation) set.poll();
                RenderChunk renderchunk = renderschematic_containerlocalrenderinformation1.renderChunk;
                EnumFacing enumfacing1 = renderschematic_containerlocalrenderinformation1.facing;

                renderOverlay = renderchunk.getPosition();
                this.renderInfos.add(renderschematic_containerlocalrenderinformation1);
                EnumFacing[] aenumfacing = EnumFacing.VALUES;
                int i = aenumfacing.length;

                for (int j = 0; j < i; ++j) {
                    EnumFacing side = aenumfacing[j];
                    RenderChunk neighborRenderChunk = this.getNeighborRenderChunk(posEye, renderOverlay, side);
                    RenderOverlay neighborRenderOverlay = this.getNeighborRenderOverlay(posEye, renderOverlay, side);

                    if ((!set1 || !renderschematic_containerlocalrenderinformation1.setFacing.contains(side.getOpposite())) && (!set1 || enumfacing1 == null || renderchunk.getCompiledChunk().isVisible(enumfacing1.getOpposite(), side)) && neighborRenderChunk != null && neighborRenderChunk.setFrameIndex(frameCount) && camera.isBoundingBoxInFrustum(neighborRenderChunk.boundingBox)) {
                        RenderSchematic.ContainerLocalRenderInformation renderInfoNext = new RenderSchematic.ContainerLocalRenderInformation(neighborRenderChunk, neighborRenderOverlay, side, renderschematic_containerlocalrenderinformation1.counter + 1);

                        renderInfoNext.setFacing.addAll(renderschematic_containerlocalrenderinformation1.setFacing);
                        renderInfoNext.setFacing.add(side);
                        set.add(renderInfoNext);
                    }
                }
            }
        }

        this.renderDispatcher.clearChunkUpdates();
        this.renderDispatcherOverlay.clearChunkUpdates();
        Set set1 = this.chunksToUpdate;
        Set set2 = this.overlaysToUpdate;

        this.chunksToUpdate = Sets.newLinkedHashSet();
        Iterator iterator = this.renderInfos.iterator();

        while (iterator.hasNext()) {
            renderschematic_containerlocalrenderinformation = (RenderSchematic.ContainerLocalRenderInformation) iterator.next();
            RenderChunk renderchunk1 = renderschematic_containerlocalrenderinformation.renderChunk;
            RenderOverlay renderoverlay = renderschematic_containerlocalrenderinformation.renderOverlay;

            if (renderchunk1.isNeedsUpdate() || set1.contains(renderchunk1)) {
                this.displayListEntitiesDirty = true;
                this.chunksToUpdate.add(renderchunk1);
            }

            if (renderoverlay.isNeedsUpdate() || set2.contains(renderoverlay)) {
                this.displayListEntitiesDirty = true;
                this.overlaysToUpdate.add(renderoverlay);
            }
        }

        this.chunksToUpdate.addAll(set1);
        this.overlaysToUpdate.addAll(set2);
        this.profiler.endSection();
    }

    private Set getVisibleSides(BlockPos pos) {
        VisGraph visgraph = new VisGraph();
        BlockPos posChunk = new BlockPos(pos.getX() & -16, pos.getY() & -16, pos.getZ() & -16);
        Iterator iterator = BlockPos.getAllInBoxMutable(posChunk, posChunk.add(15, 15, 15)).iterator();

        while (iterator.hasNext()) {
            MutableBlockPos mutableBlockPos = (MutableBlockPos) iterator.next();

            if (this.world.getBlockState(mutableBlockPos).getBlock().isOpaqueCube()) {
                visgraph.func_178606_a(mutableBlockPos);
            }
        }

        return visgraph.func_178609_b(pos);
    }

    private RenderChunk getNeighborRenderChunk(BlockPos posEye, BlockPos posChunk, EnumFacing side) {
        BlockPos offset = posChunk.offset(side, 16);

        return MathHelper.abs_int(posEye.getX() - offset.getX()) > this.renderDistanceChunks * 16 ? null : (offset.getY() >= 0 && offset.getY() < 256 ? (MathHelper.abs_int(posEye.getZ() - offset.getZ()) > this.renderDistanceChunks * 16 ? null : this.viewFrustum.getRenderChunk(offset)) : null);
    }

    private RenderOverlay getNeighborRenderOverlay(BlockPos posEye, BlockPos posChunk, EnumFacing side) {
        BlockPos offset = posChunk.offset(side, 16);

        return MathHelper.abs_int(posEye.getX() - offset.getX()) > this.renderDistanceChunks * 16 ? null : (offset.getY() >= 0 && offset.getY() < 256 ? (MathHelper.abs_int(posEye.getZ() - offset.getZ()) > this.renderDistanceChunks * 16 ? null : this.viewFrustum.getRenderOverlay(offset)) : null);
    }

    public int renderBlockLayer(EnumWorldBlockLayer layer, double partialTicks, int pass, Entity entity) {
        RenderHelper.disableStandardItemLighting();
        if (layer == EnumWorldBlockLayer.TRANSLUCENT) {
            this.profiler.startSection("translucent_sort");
            double count = RenderSchematic.PLAYER_POSITION_OFFSET.x;
            double start = RenderSchematic.PLAYER_POSITION_OFFSET.y;
            double step = RenderSchematic.PLAYER_POSITION_OFFSET.z;
            double renderInfo = count - this.prevRenderSortX;
            double renderOverlay = start - this.prevRenderSortY;
            double deltaZ = step - this.prevRenderSortZ;

            if (renderInfo * renderInfo + renderOverlay * renderOverlay + deltaZ * deltaZ > 1.0D) {
                this.prevRenderSortX = count;
                this.prevRenderSortY = start;
                this.prevRenderSortZ = step;
                int count1 = 0;
                Iterator iterator = this.renderInfos.iterator();

                while (iterator.hasNext()) {
                    RenderSchematic.ContainerLocalRenderInformation renderInfo1 = (RenderSchematic.ContainerLocalRenderInformation) iterator.next();

                    if (renderInfo1.renderChunk.compiledChunk.isLayerStarted(layer) && count1++ < 15) {
                        this.renderDispatcher.updateTransparencyLater(renderInfo1.renderChunk);
                        this.renderDispatcherOverlay.updateTransparencyLater(renderInfo1.renderOverlay);
                    }
                }
            }

            this.profiler.endSection();
        }

        this.profiler.startSection("filterempty");
        int i = 0;
        boolean isTranslucent = layer == EnumWorldBlockLayer.TRANSLUCENT;
        int j = isTranslucent ? this.renderInfos.size() - 1 : 0;
        int end = isTranslucent ? -1 : this.renderInfos.size();
        int k = isTranslucent ? -1 : 1;

        for (int index = j; index != end; index += k) {
            RenderSchematic.ContainerLocalRenderInformation renderschematic_containerlocalrenderinformation = (RenderSchematic.ContainerLocalRenderInformation) this.renderInfos.get(index);
            RenderChunk renderChunk = renderschematic_containerlocalrenderinformation.renderChunk;
            RenderOverlay renderoverlay = renderschematic_containerlocalrenderinformation.renderOverlay;

            if (!renderChunk.getCompiledChunk().isLayerEmpty(layer)) {
                ++i;
                this.renderContainer.addRenderChunk(renderChunk, layer);
            }

            if (isTranslucent && renderoverlay != null && !renderoverlay.getCompiledChunk().isLayerEmpty(layer)) {
                ++i;
                this.renderContainer.addRenderOverlay(renderoverlay);
            }
        }

        this.profiler.endStartSection("render_" + layer);
        this.renderBlockLayer(layer);
        this.profiler.endSection();
        return i;
    }

    private void renderBlockLayer(EnumWorldBlockLayer layer) {
        this.mc.entityRenderer.enableLightmap();
        this.renderContainer.renderChunkLayer(layer);
        this.mc.entityRenderer.disableLightmap();
    }

    public void updateClouds() {}

    public void renderSky(float partialTicks, int pass) {}

    public void renderClouds(float partialTicks, int pass) {}

    public boolean hasCloudFog(double x, double y, double z, float partialTicks) {
        return false;
    }

    public void updateChunks(long finishTimeNano) {
        this.displayListEntitiesDirty |= this.renderDispatcher.runChunkUploads(finishTimeNano);
        Iterator chunkIterator = this.chunksToUpdate.iterator();

        while (chunkIterator.hasNext()) {
            RenderChunk overlayIterator = (RenderChunk) chunkIterator.next();

            if (!this.renderDispatcher.updateChunkLater(overlayIterator)) {
                break;
            }

            overlayIterator.setNeedsUpdate(false);
            chunkIterator.remove();
        }

        this.displayListEntitiesDirty |= this.renderDispatcherOverlay.runChunkUploads(finishTimeNano);
        Iterator overlayIterator1 = this.overlaysToUpdate.iterator();

        while (overlayIterator1.hasNext()) {
            RenderOverlay renderOverlay = (RenderOverlay) overlayIterator1.next();

            if (!this.renderDispatcherOverlay.updateChunkLater(renderOverlay)) {
                break;
            }

            renderOverlay.setNeedsUpdate(false);
            overlayIterator1.remove();
        }

    }

    public void renderWorldBorder(Entity entity, float partialTicks) {}

    public void drawBlockDamageTexture(Tessellator tessellator, WorldRenderer worldRenderer, Entity entity, float partialTicks) {}

    public void drawSelectionBox(EntityPlayer player, MovingObjectPosition movingObjectPosition, int execute, float partialTicks) {}

    public void markBlockForUpdate(BlockPos pos) {
        int x = pos.getX();
        int y = pos.getY();
        int z = pos.getZ();

        this.markBlocksForUpdate(x - 1, y - 1, z - 1, x + 1, y + 1, z + 1);
    }

    public void notifyLightSet(BlockPos pos) {
        int x = pos.getX();
        int y = pos.getY();
        int z = pos.getZ();

        this.markBlocksForUpdate(x - 1, y - 1, z - 1, x + 1, y + 1, z + 1);
    }

    public void markBlockRangeForRenderUpdate(int x1, int y1, int z1, int x2, int y2, int z2) {
        this.markBlocksForUpdate(x1 - 1, y1 - 1, z1 - 1, x2 + 1, y2 + 1, z2 + 1);
    }

    private void markBlocksForUpdate(int x1, int y1, int z1, int x2, int y2, int z2) {
        if (this.world != null) {
            MBlockPos position = this.world.position;

            this.viewFrustum.markBlocksForUpdate(x1 - position.x, y1 - position.y, z1 - position.z, x2 - position.x, y2 - position.y, z2 - position.z);
        }
    }

    public void playRecord(String name, BlockPos pos) {}

    public void playSound(String name, double x, double y, double z, float volume, float pitch) {}

    public void playSoundToNearExcept(EntityPlayer player, String name, double x, double y, double z, float volume, float pitch) {}

    public void spawnParticle(int particleID, boolean ignoreRange, double xCoord, double yCoord, double zCoord, double xOffset, double yOffset, double zOffset, int... parameters) {}

    public void onEntityAdded(Entity entityIn) {}

    public void onEntityRemoved(Entity entityIn) {}

    public void deleteAllDisplayLists() {}

    public void broadcastSound(int soundID, BlockPos pos, int data) {}

    public void playAuxSFX(EntityPlayer player, int sfxType, BlockPos blockPosIn, int data) {}

    public void sendBlockBreakProgress(int breakerId, BlockPos pos, int progress) {}

    public void setDisplayListEntitiesDirty() {
        this.displayListEntitiesDirty = true;
    }

    @SideOnly(Side.CLIENT)
    class ContainerLocalRenderInformation {

        final RenderChunk renderChunk;
        final RenderOverlay renderOverlay;
        final EnumFacing facing;
        final Set setFacing = EnumSet.noneOf(EnumFacing.class);
        final int counter;

        ContainerLocalRenderInformation(RenderChunk renderChunk, RenderOverlay renderOverlay, EnumFacing facing, int counter) {
            this.renderChunk = renderChunk;
            this.renderOverlay = renderOverlay;
            this.facing = facing;
            this.counter = counter;
        }
    }
}
