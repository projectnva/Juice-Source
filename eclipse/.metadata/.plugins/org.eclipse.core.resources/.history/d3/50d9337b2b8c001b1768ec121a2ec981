package com.github.lunatrius.schematica.client.util;

import com.github.lunatrius.core.util.BlockPosHelper;
import com.github.lunatrius.core.util.MBlockPos;
import com.github.lunatrius.schematica.block.state.BlockStateHelper;
import com.github.lunatrius.schematica.client.world.SchematicWorld;
import com.github.lunatrius.schematica.reference.Reference;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Blocks;
import net.minecraft.item.ItemStack;
import net.minecraft.util.BlockPos;
import net.minecraft.util.MovingObjectPosition;
import net.minecraft.util.Vec3i;
import net.minecraft.world.World;

public class BlockList {

    public List getList(EntityPlayer player, SchematicWorld world, World mcWorld) {
        ArrayList blockList = new ArrayList();

        if (world == null) {
            return blockList;
        } else {
            MovingObjectPosition movingObjectPosition = new MovingObjectPosition(player);
            MBlockPos mcPos = new MBlockPos();
            Iterator iterator = BlockPosHelper.getAllInBox(BlockPos.ORIGIN, new BlockPos(world.getWidth() - 1, world.getHeight() - 1, world.getLength() - 1)).iterator();

            while (iterator.hasNext()) {
                MBlockPos pos = (MBlockPos) iterator.next();

                if (!world.isRenderingLayer || pos.getY() == world.renderingLayer) {
                    IBlockState blockState = world.getBlockState(pos);
                    Block block = blockState.getBlock();

                    if (block != Blocks.air && !world.isAirBlock(pos)) {
                        mcPos.set((Vec3i) world.position.add(pos));
                        IBlockState mcBlockState = mcWorld.getBlockState(mcPos);
                        boolean isPlaced = BlockStateHelper.areBlockStatesEqual(blockState, mcBlockState);
                        ItemStack stack = null;

                        try {
                            stack = block.getPickBlock(movingObjectPosition, world, pos, player);
                        } catch (Exception exception) {
                            Reference.logger.debug("Could not get the pick block for: {}", new Object[] { blockState, exception});
                        }

                        if (stack != null && stack.getItem() != null) {
                            BlockList.WrappedItemStack wrappedItemStack = this.findOrCreateWrappedItemStackFor(blockList, stack);

                            if (isPlaced) {
                                ++wrappedItemStack.placed;
                            }

                            ++wrappedItemStack.total;
                        } else {
                            Reference.logger.debug("Could not find the item for: {}", new Object[] { blockState});
                        }
                    }
                }
            }

            return blockList;
        }
    }

    private BlockList.WrappedItemStack findOrCreateWrappedItemStackFor(List blockList, ItemStack itemStack) {
        Iterator wrappedItemStack = blockList.iterator();

        BlockList.WrappedItemStack wrappedItemStack1;

        do {
            if (!wrappedItemStack.hasNext()) {
                BlockList.WrappedItemStack wrappedItemStack2 = new BlockList.WrappedItemStack(itemStack.copy());

                blockList.add(wrappedItemStack2);
                return wrappedItemStack2;
            }

            wrappedItemStack1 = (BlockList.WrappedItemStack) wrappedItemStack.next();
        } while (!wrappedItemStack1.itemStack.isItemEqual(itemStack));

        return wrappedItemStack1;
    }

    public static class WrappedItemStack {

        public ItemStack itemStack;
        public int placed;
        public int total;

        public WrappedItemStack(ItemStack itemStack) {
            this(itemStack, 0, 0);
        }

        public WrappedItemStack(ItemStack itemStack, int placed, int total) {
            this.itemStack = itemStack;
            this.placed = placed;
            this.total = total;
        }

        public String getItemStackDisplayName() {
            return this.itemStack.getItem().getItemStackDisplayName(this.itemStack);
        }

        public String getFormattedAmount() {
            int color = this.placed < this.total ? 99 : 97;

            return String.format("§%c%d§r/%d", new Object[] { Character.valueOf((char) color), Integer.valueOf(this.placed), Integer.valueOf(this.total)});
        }
    }
}
