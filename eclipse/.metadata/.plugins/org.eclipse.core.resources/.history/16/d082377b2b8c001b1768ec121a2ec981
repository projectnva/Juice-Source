package com.github.lunatrius.schematica.client.renderer.chunk.overlay;

import com.github.lunatrius.core.client.renderer.GeometryTessellator;
import com.github.lunatrius.schematica.block.state.BlockStateHelper;
import com.github.lunatrius.schematica.client.renderer.chunk.CompiledOverlay;
import com.github.lunatrius.schematica.client.world.SchematicWorld;
import com.github.lunatrius.schematica.handler.ConfigurationHandler;
import com.orbitclient.imsoogood.ez.orbitclient.modules.MissingBlockESP;
import java.util.Iterator;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.RegionRenderCache;
import net.minecraft.client.renderer.RenderGlobal;
import net.minecraft.client.renderer.WorldRenderer;
import net.minecraft.client.renderer.chunk.ChunkCompileTaskGenerator;
import net.minecraft.client.renderer.chunk.CompiledChunk;
import net.minecraft.client.renderer.chunk.RenderChunk;
import net.minecraft.client.renderer.chunk.VisGraph;
import net.minecraft.client.renderer.chunk.ChunkCompileTaskGenerator.Status;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.client.renderer.vertex.VertexBuffer;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumWorldBlockLayer;
import net.minecraft.world.World;

public class RenderOverlay extends RenderChunk {

    private final VertexBuffer vertexBuffer;

    public RenderOverlay(World world, RenderGlobal renderGlobal, BlockPos pos, int index) {
        super(world, renderGlobal, pos, index);
        this.vertexBuffer = OpenGlHelper.useVbo() ? new VertexBuffer(DefaultVertexFormats.POSITION_COLOR) : null;
    }

    public VertexBuffer getVertexBufferByLayer(int layer) {
        return this.vertexBuffer;
    }

    public void rebuildChunk(float x, float y, float z, ChunkCompileTaskGenerator generator) {
        CompiledOverlay compiledOverlay = new CompiledOverlay();
        BlockPos from = this.getPosition();
        BlockPos to = from.add(15, 15, 15);

        generator.getLock().lock();
        SchematicWorld schematic = (SchematicWorld) this.world;

        RegionRenderCache regionRenderCache;
        label257: {
            try {
                if (generator.getStatus() != Status.COMPILING) {
                    return;
                }

                if (from.getX() >= 0 && from.getZ() >= 0 && from.getX() < schematic.getWidth() && from.getZ() < schematic.getLength()) {
                    regionRenderCache = new RegionRenderCache(this.world, from.add(-1, -1, -1), to.add(1, 1, 1), 1);
                    generator.setCompiledChunk(compiledOverlay);
                    break label257;
                }

                generator.setCompiledChunk(CompiledChunk.DUMMY);
            } finally {
                generator.getLock().unlock();
            }

            return;
        }

        VisGraph visgraph = new VisGraph();

        if (!regionRenderCache.extendedLevelsInChunkCache()) {
            ++RenderOverlay.renderChunksUpdated;
            WorldClient mcWorld = Minecraft.getMinecraft().theWorld;
            EnumWorldBlockLayer layer = EnumWorldBlockLayer.TRANSLUCENT;
            WorldRenderer worldRenderer = generator.getRegionRenderCacheBuilder().getWorldRendererByLayer(layer);

            GeometryTessellator.setStaticDelta(ConfigurationHandler.blockDelta);
            Iterator iterator = BlockPos.getAllInBox(from, to).iterator();

            while (iterator.hasNext()) {
                BlockPos pos = (BlockPos) iterator.next();

                if ((!schematic.isRenderingLayer || schematic.renderingLayer == pos.getY()) && schematic.isInside(pos)) {
                    boolean render = false;
                    int sides = 0;
                    int color = 0;
                    IBlockState schBlockState = schematic.getBlockState(pos);
                    Block schBlock = schBlockState.getBlock();

                    if (schBlock.isOpaqueCube()) {
                        visgraph.func_178606_a(pos);
                    }

                    BlockPos mcPos = pos.add(schematic.position);
                    IBlockState mcBlockState = mcWorld.getBlockState(mcPos);
                    Block mcBlock = mcBlockState.getBlock();
                    boolean isSchAirBlock = schematic.isAirBlock(pos);
                    boolean isMcAirBlock = mcWorld.isAirBlock(mcPos) || ConfigurationHandler.isExtraAirBlock(mcBlock);

                    if (!isMcAirBlock && isSchAirBlock && ConfigurationHandler.highlightAir) {
                        render = true;
                        color = 12517567;
                        sides = this.getSides(mcBlock, mcWorld, mcPos, sides);
                    }

                    if (!render) {
                        if (ConfigurationHandler.highlight) {
                            if (!isMcAirBlock) {
                                if (schBlock != mcBlock) {
                                    render = true;
                                    color = 16711680;
                                    if (!isSchAirBlock) {
                                        MissingBlockESP.addBadBlockpos(mcPos);
                                    }
                                } else if (!BlockStateHelper.areBlockStatesEqual(schBlockState, mcBlockState)) {
                                    if (!isSchAirBlock) {
                                        MissingBlockESP.addBadBlockpos(mcPos);
                                    }

                                    render = true;
                                    color = 12541696;
                                }
                            } else if (!isSchAirBlock) {
                                render = true;
                                color = 'ë¿¿';
                                if (!isSchAirBlock) {
                                    MissingBlockESP.addBadBlockpos(mcPos);
                                }
                            }
                        }

                        if (render) {
                            sides = this.getSides(schBlock, schematic, pos, sides);
                        }
                    }

                    if (render && sides != 0) {
                        if (!compiledOverlay.isLayerStarted(layer)) {
                            compiledOverlay.setLayerStarted(layer);
                            this.preRenderBlocks(worldRenderer, from);
                        }

                        GeometryTessellator.drawCuboid(worldRenderer, pos, sides, 1056964608 | color);
                        compiledOverlay.setLayerUsed(layer);
                    } else if (!isSchAirBlock) {
                        MissingBlockESP.addGoodBlockpos(mcPos);
                    }
                }
            }

            if (compiledOverlay.isLayerStarted(layer)) {
                this.postRenderBlocks(layer, x, y, z, worldRenderer, compiledOverlay);
            }
        }

        compiledOverlay.setVisibility(visgraph.computeVisibility());
    }

    private int getSides(Block block, World world, BlockPos pos, int sides) {
        if (block.shouldSideBeRendered(world, pos.offset(EnumFacing.DOWN), EnumFacing.DOWN)) {
            sides |= 1;
        }

        if (block.shouldSideBeRendered(world, pos.offset(EnumFacing.UP), EnumFacing.UP)) {
            sides |= 2;
        }

        if (block.shouldSideBeRendered(world, pos.offset(EnumFacing.NORTH), EnumFacing.NORTH)) {
            sides |= 4;
        }

        if (block.shouldSideBeRendered(world, pos.offset(EnumFacing.SOUTH), EnumFacing.SOUTH)) {
            sides |= 8;
        }

        if (block.shouldSideBeRendered(world, pos.offset(EnumFacing.WEST), EnumFacing.WEST)) {
            sides |= 16;
        }

        if (block.shouldSideBeRendered(world, pos.offset(EnumFacing.EAST), EnumFacing.EAST)) {
            sides |= 32;
        }

        return sides;
    }

    public void preRenderBlocks(WorldRenderer worldRenderer, BlockPos pos) {
        worldRenderer.begin(7, DefaultVertexFormats.POSITION_COLOR);
        worldRenderer.setTranslation((double) (-pos.getX()), (double) (-pos.getY()), (double) (-pos.getZ()));
    }

    public void deleteGlResources() {
        super.deleteGlResources();
        if (this.vertexBuffer != null) {
            this.vertexBuffer.deleteGlBuffers();
        }

    }
}
